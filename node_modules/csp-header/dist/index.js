"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
__export(require("./constants"));
/**
 * Build CSP header value from params
 */
function getCSP(params = {}) {
    let { directives = {}, presets = {}, reportUri } = params;
    let presetsList = normalizePresetsList(presets);
    let mergedPolicies = applyPresets(directives, presetsList);
    return policyToString(mergedPolicies, reportUri);
}
exports.getCSP = getCSP;
/**
 * Build CSP nonce string
 */
function nonce(nonceKey) {
    return `'nonce-${nonceKey}'`;
}
exports.nonce = nonce;
/**
 * Build CSP header value from resolved policy
 */
function policyToString(directives, reportUri) {
    let cspStringParts = [];
    for (let directiveName in directives) {
        if (!directives.hasOwnProperty(directiveName)) {
            continue;
        }
        let directiveValue = directives[directiveName];
        let directiveRulesString = getDirectiveString(directiveName, directiveValue);
        if (directiveRulesString) {
            cspStringParts.push(directiveRulesString);
        }
    }
    if (reportUri) {
        cspStringParts.push(getReportUriDirective(reportUri));
    }
    return cspStringParts.join(' ');
}
/**
 * Build directive rules part of CSP header value
 */
function getDirectiveString(directiveName, directiveValue) {
    if (!directiveValue) {
        return '';
    }
    if (directiveName in constants_1.BOOLEAN_DIRECTIVES) {
        return `${directiveName};`;
    }
    if (directiveName in constants_1.STRING_DIRECTIVES) {
        return `${directiveName} ${directiveValue};`;
    }
    if (directiveName in constants_1.LIST_DIRECTIVES) {
        let valueString = directiveValue.join(' ');
        return `${directiveName} ${valueString};`;
    }
}
/**
 * Build report-uri directive
 */
function getReportUriDirective(reportUri) {
    return `report-uri ${reportUri};`;
}
/**
 * Normalize different presets list formats to array format
 */
function normalizePresetsList(presets) {
    return Array.isArray(presets) ? presets : Object.values(presets);
}
/**
 * Merges presets to policy
 */
function applyPresets(directives, presets) {
    let mergedPolicies = {};
    for (let preset of [directives, ...presets]) {
        for (let directiveName in preset) {
            if (!(directiveName in constants_1.ALLOWED_DIRECTIVES)) {
                continue;
            }
            directiveName;
            let currentRules = mergedPolicies[directiveName];
            let presetRules = preset[directiveName];
            mergedPolicies[directiveName] = mergeDirectiveRules(currentRules, presetRules, directiveName);
        }
    }
    return mergedPolicies;
}
function mergeDirectiveRules(directiveValue1, directiveValue2, directiveName) {
    if (directiveValue1 === undefined) {
        return directiveValue2;
    }
    if (directiveValue2 === undefined) {
        return directiveValue1;
    }
    if (directiveName in constants_1.LIST_DIRECTIVES) {
        return getUniqRules([
            ...directiveValue1,
            ...directiveValue2
        ]);
    }
    return directiveValue2;
}
function getUniqRules(rules) {
    return Array.from(new Set(rules));
}
//# sourceMappingURL=index.js.map